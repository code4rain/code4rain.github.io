<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alex Kyoungdon&#39;s Blog</title>
    <description>Alex Kyoungdon Jang&#39;s Blog.
</description>
    <link>http://code4rain.github.io/</link>
    <atom:link href="http://code4rain.github.io/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Posting to Tumblr With Emacs</title>
        <description>&lt;h1&gt;What is the tumblesocks&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gcr/tumblesocks&quot;&gt;tumblesocks&lt;/a&gt; is the one of emacs package. It helps to post tumblr via emacs editor. You can download it from melpa, gnu and github.&lt;/p&gt;

&lt;h1&gt;How to setup&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Download the package: simply use &lt;code&gt;M-x package-install tumblesocks&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add the followings to your &lt;code&gt;.emcacs&lt;/code&gt;:
&lt;pre&gt;&lt;code&gt;(require &amp;#39;tumblesocks)
(setq tumblesocks-blog &amp;quot;YourBlogName.tumblr.com&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;M-x tumblesocks-api-test-auth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tumblesocks will open the browser and access to tumblr to get auth code.&lt;/li&gt;
&lt;li&gt;Copy the auth code and paste it to emacs prompt&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;How to post with tumblesocks&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Make new post: &lt;code&gt;M-x tumblesocks-compose-new-post&lt;/code&gt; or other commands.&lt;/li&gt;
&lt;li&gt;Write the post - I recommnad &lt;em&gt;markdown&lt;/em&gt; editor.&lt;/li&gt;
&lt;li&gt;Finish writing: &lt;code&gt;M-x tumblesocks-compose-finish&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If you need to edit existing post, use &lt;code&gt;M-x tumblesocks-compose-edit-post&lt;/code&gt; - &lt;strong&gt;currently not working for me.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;Some commands to make the post&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tumblesocks-text-post-from-region&lt;/code&gt;: Instantly create a post with the contents of region.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tumblesocks-text-post-from-buffer&lt;/code&gt;: Instantly create a post from the entire buffer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tumblesocks-compose-new-from-region&lt;/code&gt;: Open a buffer and start writing a new post. The contents of region will be copied over.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tumblesocks-compose-new-from-highlighted-region&lt;/code&gt;: Open a buffer and start writing a new post. The contents of region will be syntax-highlighted and copied into the post as formatted HTML. This is super-useful for including source code into your tumbles.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tumblesocks-compose-insert-highlighted-region&lt;/code&gt;: Insert the syntax-highlighted region at the end of post you&amp;rsquo;re currently writing.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 09 May 2016 01:29:16 +0900</pubDate>
        <link>http://code4rain.github.io/2016/05/09/posting-to-tumblr-with-emacs/</link>
        <guid isPermaLink="true">http://code4rain.github.io/2016/05/09/posting-to-tumblr-with-emacs/</guid>
      </item>
    
      <item>
        <title>TMUX - 창분할하기 &amp; 빌드걸고 퇴근하기</title>
        <description>&lt;p&gt;TMX는 terminal multiplexer로 터미널에서 사용하는 프로그램들을 손쉽게 switch하거나 backgroud로 수행할 수 있게 도와주는 툴입니다.&lt;br&gt;
&lt;img src=&quot;/images/tmux_preview.gif&quot; alt=&quot;preview&quot;&gt;&lt;/p&gt;

&lt;p&gt;TMUX를 사용하면&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;터미널창을 분할해서 사용할 수 있습니다. (위 그림에서는 왼쪽에는 VI, 오른쪽 위는 TIG, 오른쪽 아래는 Shell로 분할했습니다.)&lt;/li&gt;
&lt;li&gt;Perforce Sync / 모델 빌드를 걸어두고 다음날 출근해서 확인할 수 있습니다. (session유지)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;설치방법&lt;/h2&gt;

&lt;h3&gt;TMUX최신 버전을 설치합니다.&lt;/h3&gt;

&lt;p&gt;(&lt;code&gt;apt-get install tmux&lt;/code&gt;로도 설치가능하지만 굉장히 오래전 버전입니다&amp;hellip;)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;To get and build the latest from version control:
$ git clone git://git.code.sf.net/p/tmux/tmux-code tmux
$ cd tmux
$ sh autogen.sh
$ ./configure &amp;amp;&amp;amp; make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Root권한이 있는 사용자라면 &lt;code&gt;sudo make install&lt;/code&gt;로 모든 사용자가 해당 버전을 사용하게끔해 줄 수 있습니다.&lt;br&gt;
제가 설정해둔 설정파일을 사용하시면 좀 더 편할 듯싶습니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/.tmux.conf&lt;/code&gt;로 저장하시면 됩니다.&lt;/p&gt;

&lt;p&gt;VI의 color scheme이 정상적으로 동작하게끔하기 위해서 .bashrc 등에 아래 줄을 추가해둡니다.&lt;br&gt;
&lt;code&gt;alias tmux=&amp;#39;TERM=xterm-256color tmux -2&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;사용방법&lt;/h2&gt;

&lt;p&gt;제 설정파일(설정파일은 포스팅 마지막에 있습니다.)을 적용했다고 가정하고 사용법을 설명드리도록 하겠습니다.&lt;br&gt;
기본적인 invoke키는 &lt;code&gt;Ctrl+b&lt;/code&gt;이지만 저는 &lt;code&gt;Ctrl+j&lt;/code&gt;로 변경해두었습니다.&lt;/p&gt;

&lt;h4&gt;시작하기&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;tmux&lt;/code&gt; 혹은 &lt;code&gt;tmux new -s &amp;lt;원하는 이름&amp;gt;&lt;/code&gt; &lt;br&gt;
: 추후에 attache(재사용)을 하기 편하게끔 이름을 지정하시는게 좋습니다. &lt;code&gt;tmux new -s normal&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;창 분할하기&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Ctrl+j&lt;/code&gt;를 누른 후에 | 를 누르면 좌우로 분할되고, &lt;br&gt;
&lt;code&gt;Ctrl+j&lt;/code&gt;를 누른 후에 - 를 누르면 상하로 분할됩니다. &lt;/p&gt;

&lt;h4&gt;창 이동하기&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Ctrl+j&lt;/code&gt;를 누르고 다시 &lt;code&gt;Ctrl+j&lt;/code&gt;를 누르면 이전 창으로 돌아갑니다. &lt;br&gt;
&lt;code&gt;Ctrl+j&lt;/code&gt;를 누르고 &lt;code&gt;q&lt;/code&gt;를 누르면 창마다 숫자가 나오는데 이 때 해당 숫자를 누르면 그 창으로 이동합니다. &lt;br&gt;
&lt;img src=&quot;/images/tmux_number.gif&quot; alt=&quot;move with number&quot;&gt;&lt;/p&gt;

&lt;h4&gt;Tab 만들기&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Ctrl+j&lt;/code&gt;를 누른 후에 &lt;code&gt;c&lt;/code&gt;를 누르면 새로운 tab이 생성됩니다.&lt;/p&gt;

&lt;h4&gt;Tab간 이동하기&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Ctrl+j&lt;/code&gt;를 누른 후에 &lt;code&gt;n&lt;/code&gt;을 누르면 다음 tab으로 이동합니다.&lt;br&gt;
&lt;code&gt;Alt+&amp;lt;숫자키&amp;gt;&lt;/code&gt;를 누르면 해당 tab으로 이동합니다.&lt;/p&gt;

&lt;h4&gt;창 닫기&lt;/h4&gt;

&lt;p&gt;shell에서 exit명령을 입력합니다.&lt;br&gt;
&lt;code&gt;Ctrl+j&lt;/code&gt;를 누른 후에 &lt;code&gt;x&lt;/code&gt;를 누르면 해당 pane을 닫을 것인지 묻습니다. 이 때 &lt;code&gt;y&lt;/code&gt;를 선택하면 해당 창이 닫힙니다.&lt;/p&gt;

&lt;h4&gt;Detache / Attache 사용하기 (build걸고 퇴근하기)&lt;/h4&gt;

&lt;p&gt;tmux를 실행하고 나서 빌드를 실행합니다.&lt;br&gt;
&lt;code&gt;Ctrl+j&lt;/code&gt;를 누르고 &lt;code&gt;d&lt;/code&gt;를 누르면 [detached (from session xxx)] 라고 뜨면서 tmux를 실행하기 전 Shell로 빠져나옵니다.&lt;br&gt;
퇴근합니다.~&lt;br&gt;
다음날 와서 &lt;code&gt;tmux attach -t xxx&lt;/code&gt;를 치면 퇴근 전 화면으로 돌아갑니다.&lt;/p&gt;

&lt;h4&gt;Zoom기능 사용하기&lt;/h4&gt;

&lt;p&gt;tmux최신버전에는 zoom이라는 기능이 있습니다. 창을 분할해서 사용하다가 잠시 전체 화면으로 바꾸고, 다시 원래대로 돌아갈 수 있는 기능입니다.&lt;br&gt;
&lt;code&gt;Ctrl+j&lt;/code&gt;를 누른 후에 &lt;code&gt;z&lt;/code&gt;를 누르면 현재 커서가 위차한 창이 전체 화면으로 전환되고, 다시 &lt;code&gt;Ctrl+j&lt;/code&gt;를 누른 후에 &lt;code&gt;z&lt;/code&gt;를 누르면 분할되었던 상태로 돌아가게 됩니다.&lt;/p&gt;

&lt;h2&gt;More&lt;/h2&gt;

&lt;h3&gt;제 설정에는 bash대신 zsh가 tmux로 접속하면 실행되게 되어 있습니다.&lt;/h3&gt;

&lt;p&gt;해당 설정을 원래대로 bash로 변경하고 싶으시면 &lt;code&gt;~/.tmux.conf&lt;/code&gt;에서&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;     # set-option -g default-command &quot;bash&quot;
     set-option -g default-command &quot;zsh&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zsh 부부분을 주석처리하시고 bash부분을 주석해제 해주시면 됩니다. (#은 주석처리입니다.)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tmux에 간단한 설명은 아래를 참고하세요.

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://nodeqa.com/nodejs_ref/99&quot;&gt;http://nodeqa.com/nodejs_ref/99&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;매번 tmux를 설정하고 창을 분할하는 작업을 하게 되는데 이걸 미리 설정해서 할 수 있는 Tool도 있습니다.

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tmuxinator/tmuxinator&quot;&gt;https://github.com/tmuxinator/tmuxinator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;저도 설정해서 쓰고 있는데 mux session-name으로 간단히 new/attache를 할 수 있어서 편합니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;.tmux.conf&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;.tmumx.conf&lt;/code&gt;파일입니다. 아래 파일을 &lt;code&gt;~/.tmux.conf&lt;/code&gt;로 저장하시면 됩니다.&lt;br&gt;
&lt;script src=&quot;https://gist.github.com/code4rain/374c53829bea88cbe328.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Mar 2016 01:50:00 +0900</pubDate>
        <link>http://code4rain.github.io/2016/03/15/tmux/</link>
        <guid isPermaLink="true">http://code4rain.github.io/2016/03/15/tmux/</guid>
      </item>
    
      <item>
        <title>Restart blogging</title>
        <description>&lt;p&gt;기존에는 tistory나 wordpress와 같은 블로깅툴을 사용하고 있었다. (많이 쓰지는 않고 있었지만…)&lt;/p&gt;

&lt;p&gt;하지만 해당 툴을 사용하게 되면 특정 웹사이트로 접속해서 글을 남겨야하고 이 때 내가 사용하는 에디터가 아닌 웹화면에서 글을 남기는 건 좀 불편한 일이었다. 물론 에디터에서 수정하고 복붙하는 방법도 있지만 웬지 귀찮아져서 잘하지 않게 되었다.&lt;/p&gt;

&lt;p&gt;덕분에 글을 쓰는 양 자체가 많이 줄게 되서 블로깅 자체를 하지않는 수준에 까지 이르르게 되서 가끔씩 예전에 정리해뒀던 글을 올리는 것외에는 잘하지 않게 되었다.&lt;/p&gt;

&lt;p&gt;그러다가 얼마전에 에디터를 emcas로 변경하면서 자주 글을 쓰자고 마음을 먹었고 그 일환의 하나로 블로깅을 다시 시작해보려고 한다.&lt;/p&gt;

&lt;p&gt;Let’s write &amp;amp; play :)&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 20:09:55 +0900</pubDate>
        <link>http://code4rain.github.io/2016/03/14/move-jekyll/</link>
        <guid isPermaLink="true">http://code4rain.github.io/2016/03/14/move-jekyll/</guid>
      </item>
    
      <item>
        <title>Migrated From Vim to Emacs</title>
        <description>&lt;p&gt;프로그래머 세계에서 끊이지 않는 논쟁 중 하나는 어떤 에디터를 사용하는 지에 관한 논쟁이다.&lt;br&gt;
세상에 있는 수많은 에디터와 그 에디터들을 찬양하는 수많은 글들을 읽다가 보면 과연 어떠한 에디터가 최고의 에디터인지에 대해 혼란해지기도 한다.&lt;/p&gt;

&lt;p&gt;이러한 에디터 논쟁에서 빠지지 않고 그 자리를 차지하는 두 가지 에디터가 있다.&lt;br&gt;
vi, 혹은 그 변형인 vim과 emacs이다.&lt;/p&gt;

&lt;p&gt;두 가지 에디터 모두 오랜 역사를 가지고 있고, 오랜 시간 동안 사람들의 사랑을 받을 만한 많은 장점이 있다.&lt;/p&gt;

&lt;p&gt;공통된 장점으로 보자면 에디터의 기능을 확장시킬 수 있는 수많은 플러그인이 존재한다는 점을 들 수 있다. 두 에디터 단순한 에디터라기 보다는 일종의 플랫폼으로 동작하여 수많은 플러그인을 활용하여 스스로의 기능을 발전시켜왔다.&lt;/p&gt;

&lt;p&gt;vi의 경우를 보자면 특이한 키맵과 편집모드가 있다. 초심자에게, 특히나 GUI로 컴퓨터를 접하기 시작한 사람들에게는 괴랄한 인터페이스가 초기 진입장벽을 만들지만 한 번 익숙해지면 마우스 없이 키보드에서 손을 거의 떼지않고 문서 편집을 할 수 있다는 장점때문에 vi의 신봉자로 거듭나게 된다. 나 역시 초기의 어려움을 극복(?)하고 나서부터는 거의 모든 편집을 vi를 사용하거나 에디터에 있는 키맵을 수정하여 vi와 비슷하게 맞추게 되어버렸다.&lt;/p&gt;

&lt;p&gt;emacs의 경우는 일종의 편집기라기 보다는 플랫폼이라는 말이 어울릴 정도로 프로그래머에게 높은 자유도와 확장성을 제공한다. 하지만 이러한 확장성은 lisp라는 언어를 배우고 그에 맞게 자신이 커스터마이즈해야하는 노력과 시간이 많이 들어가는 까다로움도 동시에 존재했다. 사실 나도 vi를 배우기 시작할 때 또 다른 옵션의 하나로 emacs를 고려했지만 초기 설정의 어려움으로 인해서 결국 적응하지 못하고 포기한 바 있다.&lt;/p&gt;

&lt;p&gt;하지만 시간이 흐르고 vi에 익숙해지면서 vi로 할 수 있는 기능의 제약성을 조금씩 느끼기 시작했다. 아무래도 vi가 가진 에디터라는 한계로 인해 다양한 다른 툴과 연계를 해야하지만 이러한 과정에서 나타나는 인터페이스의 비일관성과 귀찮음이 점점 커져가고 있었던 것이다. 이러한 도중에 Youtube에서 보게된 &lt;a href=&quot;https://www.youtube.com/watch?v=JWD1Fpdd4Pc&quot;&gt;Evil Mode: Or, How I Learned to Stop Worrying and Love Emacs&lt;/a&gt;라는 동영상은 emacs에 대한 관심을 다시 불러일으키게 되었다.&lt;br&gt;
기존 vi사용자를 위해 emacs에 추가된 evil package는 vi keymap때문에 못 옮긴다는 핑계를 날려주었고, 초기 설정의 복잡함은 &lt;a href=&quot;https://github.com/syl20bnr/spacemacs&quot;&gt;spacemacs&lt;/a&gt;라는 프로젝트 덕분에 명령어 몇 줄과 설정파일 수정 몇 줄을 통해서 간단히 해결되게 되었다.&lt;/p&gt;

&lt;p&gt;덕분에 지금은 윈도우를 켜자마자 emacs를 켜고 파일 편집, 논문 작성, 블로그 작성, todo list관리를 하나의 에디터에서 수행할 수 있게 되었다.&lt;/p&gt;

&lt;h1&gt;recommand for previous vimer&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;evil package를 설치하자.&lt;/li&gt;
&lt;li&gt;기왕이면 spacemacs를 통채로 설치하면 초기 설정이 편하다. (spacemacs의 기본 keymap은 vim을 base로 한다.)&lt;/li&gt;
&lt;li&gt;emacs 첫 구동에는 시간이 걸린다. 하지만 종료를 하지 않으면 된다…&lt;/li&gt;
&lt;li&gt;todo 관리를 위해서 org모드 사용법은 배워두면 좋다.&lt;/li&gt;
&lt;li&gt;vi에서 사용하던 플러그인은 대부분 찾아보면 다 있다. (더 좋은 경우가 많다.)&lt;/li&gt;
&lt;li&gt;windows용 gvim보다 emacs가 linux/windows를 가리지 않는 호환성이 더 좋다. (애초에 거의 모든 기능이 자체적으로 구현되어 있다.)&lt;/li&gt;
&lt;li&gt;lifetime editor로 emacs는 좋은 선택이다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 19:30:27 +0900</pubDate>
        <link>http://code4rain.github.io/2016/03/14/migrated-from-vim-to-emacs/</link>
        <guid isPermaLink="true">http://code4rain.github.io/2016/03/14/migrated-from-vim-to-emacs/</guid>
      </item>
    
      <item>
        <title>Change Outlook Subject with Python</title>
        <description>&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;직장에 다니게 되면서 e-mail은 뗄레야 뗄 수 없는 사이가 되었습니다. 업무지시부터 각종 정보에 이르기까지 모든 것이 e-mail을 통해서 전달되기 때문이죠. 그런데 회사 메일은 받은 편지함 공간에 제약이 있었습니다. 읽지 않은 메일은 2주간, 읽은 메일은 1주일간만 보관 가능했습니다. 워낙 많은 사람들이 쓰고 있어서 공간제약은 어쩔 수 없는 면이 있죠. 그래서 대부분 선배, 동료, 후배들은 백업 용도로 아웃룩을 사용하고 있습니다. 출장 나가서 본 많은 주재원분들이나 업체에서는 아웃룩을 메인으로 쓰지만 회사 내부 규정상 아웃룩 발신을 제한하고 있어서 우리 회사에서는 메인보다는 백업용도로 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;아웃룩 2003까지는 뭐 그러려니 하고 search plugin을 설치해서 쓰고 있다가, 2010에 &lt;a href=&quot;http://support.microsoft.com/kb/2274243/ko&quot;&gt;conversation view(대화보기)&lt;/a&gt;라는 기능이 추가된 것을 알게 되었습니다. 메일 제목을 기준으로(엄밀히 이야기하면 메일 제목은 아닙니다만) 메일을 묶어주는 기능입니다.&lt;/p&gt;

&lt;p&gt;하루에 오는 메일들이 대부분 Reply나 Foword 형식이기 때문에 이 기능을 쓰게 되면 하루에 오는 몇 백통의 메일을 몇 십개 Thread로 묶어서 보여주는 효과가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;오호라~!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하지만 난관에 봉착합니다. 이 기능은 아웃룩에서 수발신한 메일들만 묶어줍니다. 회사메일에서 reply, foword를 하게되면 다른 conversation subject를 가진 메일로 인식하고 묶어주질 못하는 거죠.&lt;/p&gt;

&lt;p&gt;SW engineer가 이대로 포기할 순 없어서 검색해보기 시작합니다.&lt;/p&gt;

&lt;p&gt;우리의 친구 Google과 stackoverflow를 찾아보다가 &lt;a href=&quot;http://stackoverflow.com/questions/1440233/possible-to-intercept-and-rewrite-email-on-outlook-client-side-using-ironpython&quot;&gt;힌트&lt;/a&gt;를 발견합니다.&lt;br&gt;
Python으로 뭔가 쿵짝쿵짝하면 될 것같은 느낌이 듭니다. 오호~&lt;/p&gt;

&lt;p&gt;열심히 스크립트도 만들고 수정해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;뭔가 되는 듯하더니 안됩니다.ㅠㅠ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;음 다시 Google과 stackoverflow를 뒤져봅니다.&lt;br&gt;
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/office/ff869318.aspx&quot;&gt;MSDN&lt;/a&gt;에 나온 걸 보니 conversationTopic을 변경이 안된다고 합니다. - READ Only attribute.&lt;/p&gt;

&lt;p&gt;이런&amp;hellip;&lt;/p&gt;

&lt;p&gt;하지만 또 뒤져봅니다.&lt;/p&gt;

&lt;p&gt;&amp;hellip; (_ _) (- - ) ( - -)&lt;/p&gt;

&lt;p&gt;걸렸습니다. Redemption DLL을 깔면 수정할 수 있답니다. (오예~)&lt;/p&gt;

&lt;p&gt;그래서 기존에 온 메일을 일괄 정리하는 스크립트를 만듭니다. 쓱싹쓱싹 돌 때 심심하니 메일 하나를 처리하면 .하나를 찍어주도록 합니다.&lt;br&gt;
다 되고 나서 Conversation View로 바꿔봅니다.&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;잘됩니다.ㅋㅋㅋㅋ&lt;/p&gt;

&lt;p&gt;이제 매번 스크립트를 돌리기가 귀찮아집니다. 보통은 여기까지하고 그만두지만, 이번엔 아웃룩 VBA까지 건들여봅니다. 뚝딱뚝딱&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이힝~&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 메일이 오면 자동으로 정리해주도록 변경합니다. 아.. 내가 만든 VBA스크립트는 인증받지 않은 스크립트라 보안을 해제해줘야 합니다.&lt;br&gt;
설마 회사에 스팸용 VBA 스크립트가 들어오진 않을테니, 보안담당자를 믿고 보안도 해제합니다.&lt;/p&gt;

&lt;p&gt;길고긴 삽질이 끝났습니다.&lt;/p&gt;

&lt;h2&gt;설치 방법&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Download and install&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Windows용 Python을 설치합니다.&lt;/li&gt;
&lt;li&gt;Python은 Outlook을 32bit을 설치했으면 32bit을, 64bit을 설치했으면 64bit을 설치합니다.

&lt;ul&gt;
&lt;li&gt;Python Download : &lt;a href=&quot;http://www.python.org/ftp/python/2.7.5/python-2.7.5.msi&quot;&gt;2.7.5 32bit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python용 win32 library도 다운받습니다. : &lt;a href=&quot;http://sourceforge.net/projects/pywin32/files/pywin32/Build%20218/pywin32-218.win32-py2.7.exe/download&quot;&gt;pywin32-218.win32-py2.7.exe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redemption DLL도 설치합니다. (설치가 잘 안되면 관리자 권한으로 설치합니다.) : &lt;a href=&quot;http://www.dimastr.com/redemption/Redemption.zip&quot;&gt;Redemption&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;기존 메일을 정리하는 스크립트&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;스크립트를 작성합니다. 아래 내용을 복붙해서 conversation.py로 만듭니다.&lt;br&gt;
python이 제대로 설치되었다면 conversation.py를 double click하면 잘 실행이 됩니다.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/code4rain/28057bc26d7ba343e59f.js?file=conversation.py&quot;&gt; &lt;/script&gt;

&lt;p&gt;메일이 오면 자동으로 변경해주는 건 VBA스크립트를 만들어야 합니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Mar 2014 10:42:00 +0900</pubDate>
        <link>http://code4rain.github.io/2014/03/24/change-outlook-subject-with-python/</link>
        <guid isPermaLink="true">http://code4rain.github.io/2014/03/24/change-outlook-subject-with-python/</guid>
      </item>
    
      <item>
        <title>PUSH된 COMMIT내용 수정하기(Gerrit Review전)</title>
        <description>&lt;p&gt;Git에서 수정하고 Gerrit에 Push를 하였으나 아직 Review가 끝나지 않아 Merge되지 않은 상태에서 Commit을 수정해서 다시 Gerrit에 Patch #2로 올리는 간단한 방법을 설명한다.&lt;/p&gt;

&lt;p&gt;수정하고 싶은 commit이 현재 HEAD일 경우입니다.&lt;/p&gt;

&lt;h1&gt;comit에 있는 일부 파일만 변경하고 싶을 때&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;수정하고 싶은 파일(a.c) 편집&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add a.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit --amend -C HEAD&lt;/code&gt; // -C옵션은 HEAD에 있는 commit 내용을 그대로 사용한다는 의미입니다. 고로 Change Id도 유지되겠죠.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;commit에 있는 파일 중 하나를 이전으로 돌리고 싶을 떄&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git checkout HEAD^&lt;/code&gt; &amp;ndash; &amp;lt;돌리고 싶은 파일명&amp;gt; // HEAD&lt;sup&gt;는&lt;/sup&gt; 현재 HEAD 바로 전 commit 내용을 기준으로 돌리겠다는 의미. HEAD^ 위치에 원하는 Commit의 SHA ID를 써주어도 됨.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add &amp;lt;돌리고 싶은 파일명&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit --amend -C HEAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 14 Dec 2012 12:59:00 +0900</pubDate>
        <link>http://code4rain.github.io/2012/12/14/pushdoen-commitnaeyong-sujeonghagi-gerrit-reviewjeon/</link>
        <guid isPermaLink="true">http://code4rain.github.io/2012/12/14/pushdoen-commitnaeyong-sujeonghagi-gerrit-reviewjeon/</guid>
      </item>
    
      <item>
        <title>Gvim 기본 시작 위치 변경</title>
        <description>&lt;p&gt;Windows에 설치된 Gvim을 메뉴에서 실행하게 되면 기본 저장 위치는 gvim이 시작된 위치로 저장된다.&lt;br&gt;
예를 들면 &lt;code&gt;:w test.md&lt;/code&gt;라고 명령을 주는 경우에 내 PC의 경우에는 c:\windows\system 폴더에 test.md 파일이 저장이 된다.&lt;/p&gt;

&lt;p&gt;이것을 해결하기 위해서는 메뉴에 있는 gvim icon에서 오른쪽 마우스버튼을 눌러 속성창을 띄우고 나서 &lt;code&gt;시작 위치(S):&lt;/code&gt;에 자신이 원하는 디렉토리를 아래처럼 추가시켜준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gvim_cap00.png&quot; alt=&quot;Gvim short cut sample&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Dec 2012 10:40:00 +0900</pubDate>
        <link>http://code4rain.github.io/2012/12/13/gvim-gibon-sijag-wici-byeongyeong/</link>
        <guid isPermaLink="true">http://code4rain.github.io/2012/12/13/gvim-gibon-sijag-wici-byeongyeong/</guid>
      </item>
    
  </channel>
</rss>
